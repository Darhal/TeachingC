%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% I, the copyright holder of this work, release this work into the
%% public domain. This applies worldwide. In some countries this may
%% not be legally possible; if so: I grant anyone the right to use
%% this work for any purpose, without any conditions, unless such
%% conditions are required by law.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass{beamer}
\usetheme[faculty=wi]{fibeamer}
\usepackage[utf8]{inputenc}
\usepackage[
  main=french,
  french
]{babel}

\title{Language C}
\subtitle{Université de Lorraine - Télécom Nancy}
\author{Omar CHIDA}

\usepackage{ragged2e}  % `\justifying` text
\usepackage{booktabs}  % Tables
\usepackage{tabularx}
\usepackage{tikz}      % Diagrams
\usetikzlibrary{calc, shapes, backgrounds}
\usepackage{amsmath, amssymb}
\usepackage{url}       % `\url`s
\usepackage{listings}  % Code listings
\usepackage{xcolor}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{arrows}
\usepackage{drawstack}

\frenchspacing
\begin{document}
  \frame[c]{\maketitle}

  \AtBeginSection[]{% Print an outline at the beginning of sections
    \begin{frame}<beamer>
      \frametitle{Chapitre \thesection}
      \tableofcontents[currentsection,currentsubsection,subsectionstyle=show/shaded/hide]
      \addtocounter{framenumber}{-1}
    \end{frame}}

  \begin{darkframes}
  	\include{intro}
	\include{compilation}
	
  	\section{La langage C}
  	\subsection{Les bases}
  	\begin{frame}{In the beginning there was main}
  		\begin{block}{La fonction main}
  			La fonction \alert{main} est le point d'entrée du programme \footnote[frame]{l'exécutable}.
  		\end{block}
  		\begin{exampleblock}{Profils possibles :}
  			\begin{itemize}
  				\item \texttt{int main()}
  				\item \texttt{int main(int argc, char** argv)}
  			\end{itemize}
  		\end{exampleblock}
  		\begin{alertblock}{Profils qui compilent mais avec un Warning:}
  			\begin{itemize}
	  			\item \texttt{void main()}
	  			\item \texttt{void main(int argc, char** argv)}
  			\end{itemize}
  		\end{alertblock}
  	\end{frame}
  
  	\begin{frame}{In the beginning there was main}
		\framesubtitle{Les arguments de main}
		\begin{itemize}
			\item \alert{argc} : Indique le nombre d'arguments passés au programme. La valeur minimale de \texttt{argc} est 1 car le premier argument est toujours le nom du programme.
			\item \alert{argv} : Un tableau de chaîne contenant les arguments passés au programme, \texttt{argv[0]} est le nom du programme, \texttt{argv[1]} est le nom du premier argument, et ainsi de suite.
		\end{itemize}
  	\end{frame}
  
  	\begin{frame}{In the beginning there was main}
	  	\begin{exampleblock}{Exemple :}
	  		Soit la commande suivante :~~"\texttt{./a.out abc w 23 1}" \\
	  		- \texttt{argc} : vaut 5 \\
	  		- \texttt{argv[0]} : est la chaine "./a.out" \\
	  		- \texttt{argv[1]} : est la chaine "abc" \\
	  		- \texttt{argv[2]} : est la chaine "w" \\
	  		- \texttt{argv[3]} : est la chaine "23" \\
	  		- \texttt{argv[4]} : est la chaine "1" \\
	  	\end{exampleblock}
  	\end{frame}
  
  	\begin{frame}{Les types de base}
  		\begin{table}[!b]
  			{\carlitoTLF % Use monospaced lining figures
  			\begin{tabularx}{\textwidth}{Xrrr}
  				\textbf{Type} & \textbf{Taille min} & \textbf{Intervalle} & \textbf{Spécificateur de format} \\
  				\toprule
  				\texttt{char}      & 1o  & -127..127  		   & \texttt{\%c}    				    \\
  				\texttt{short}     & 2o  & -32767..32767  	   & \texttt{\%c} ou \texttt{\%hhi}     \\
  				\texttt{int}       & 4o  & $-2^{31}$..$2^{31}$ & \texttt{\%d}    				    \\
  				\texttt{long long} & 8o  & $-2^{63}$..$2^{63}$ & \texttt{\%lld}  				    \\
  				\texttt{float}     & 4o  &    ..    		   & \texttt{\%f}    				    \\
  				\texttt{double}    & 8o  &    ..   			   & \texttt{\%lf}   					\\
  				\bottomrule
  			\end{tabularx}}
  			\caption{Les types de base signés en C}
  		\end{table}
  	\end{frame}
  
  	\begin{frame}{Les types de base}
  		\begin{table}[!b]
  			{\carlitoTLF % Use monospaced lining figures
  				\begin{tabularx}{\textwidth}{Xrrr}
  					\textbf{Type} & \textbf{Taille min} & \textbf{Intervalle} & \textbf{Spécificateur de format} \\
  					\toprule
  					\texttt{unsigned char}      & 1o  & 0..255  		    & \texttt{\%c}    				    \\
  					\texttt{unsigned short}     & 2o  & 0..65535  	   		& \texttt{\%c} ou \texttt{\%hhu}    \\
  					\texttt{unsigned int}       & 4o  & 0..$2^{32}-1$ 		& \texttt{\%u}    				    \\
  					\texttt{unsigned long long} & 8o  & 0..$2^{64}-1$ 		& \texttt{\%llu}  				    \\
  					\bottomrule
  			\end{tabularx}}
  			\caption{Les types de base non-signés en C}
  		\end{table}
  	\end{frame}
 	%% TODO: Add fundamental types, their sizes how to print them, etcc
 	%% TODO: Add how to declare a variable
 
\defverbatim[colored]\ifsignle{
\begin{lstlisting}[language=C,tabsize=2]
if (some_condition)
	statment; // Une seule instruction, cad un seul point-virgule	
\end{lstlisting}}
  
\defverbatim[colored]\ifmulti{
\begin{lstlisting}[language=C,tabsize=2]
if (some_condition) {
	statment_1;
	statment_2;
	// ...
	statment_N;
}
\end{lstlisting}}

\defverbatim[colored]\ifelsesignle{
\begin{lstlisting}[language=C,tabsize=2]
if (some_condition)
	statment; // Une seule instruction, cad un seul point-virgule	
[[else
	statment2; // Un seul point-virgule	
]]
\end{lstlisting}}

\defverbatim[colored]\ifelsemulti{
\begin{lstlisting}[language=C,tabsize=2]
if (some_condition1) {
	statment_1;
	// ...
	statment_N;
} [[ else if (some_condition2) {
	statment_1;
	// ...
	statment_N;
// Possibilite d'ajouter plusieurs blocs else if 
} ]] [[ else {
	statment_1;
	// ...
	statment_N;
} ]]
\end{lstlisting}}
  	\begin{frame}{Les conditions}
  		\begin{block}{Syntaxe : Première possibilité}
  			\ifelsesignle
  		\end{block}
		\begin{alertblock}{N.B. :}
			Ce qui est mis entre $\big[\big[~~...~~\big]\big]$ est facultatif.
		\end{alertblock}
  	\end{frame}
  	
	\begin{frame}{Les conditions}
		  		\begin{block}{Syntaxe : Deuxième possibilité}
			\ifelsemulti
		\end{block}
	\end{frame}

\defverbatim[colored]\ifexampleone{
\begin{lstlisting}[language=C,tabsize=2]
int i = 0;
if (i--)
	puts("Hello World");
\end{lstlisting}}

\defverbatim[colored]\ifexampletwo{
\begin{lstlisting}[language=C,tabsize=2]
int i = -1;
if (i++)
	puts("Hello World");
\end{lstlisting}}

\defverbatim[colored]\ifexamplethree{
\begin{lstlisting}[language=C,tabsize=2]
int i = -1;
if (i++)
	if (++i)
		if ('c')
			puts("Hello World");
\end{lstlisting}}

	\begin{frame}{Les conditions}
		\begin{block}{Comment une condition est évaluée  ?}
			Le type \alert{booléen } n'existe pas en C. Si une expression est évaluée à 0, elle est considérée comme \alert{False}, sinon elle est considérée comme \alert{True}.
		\end{block}
		%% TODO: Do switch statments here!!! 
	\end{frame}

	\begin{frame}{Les conditions : Exemples}	
		\begin{center}
			\begin{minipage}[t]{0.48\linewidth}
				\text{Exemple 1 :}
				\ifexampleone
			\end{minipage}
			\qquad
			\begin{minipage}[t]{0.48\linewidth}
				\text{Exemple 2 :}
				\ifexampletwo
			\end{minipage}
			\begin{minipage}[t]{0.48\linewidth}
				\text{Exemple 3 :}
				\ifexamplethree
			\end{minipage}
		\end{center}
	\end{frame}

	\begin{frame}{Les conditions : Exemples}	
		\text{Exemple 1 : \alert{(N'affiche rien)}}
		\ifexampleone
		\text{Exemple 2 : \alert{(Affiche "Hello World")}}
		\ifexampletwo
		\text{Exemple 3 : \alert{(Affiche "Hello World")}}
		\ifexamplethree
	\end{frame}

\defverbatim[colored]\forsyntax{
\begin{lstlisting}[language=C,tabsize=2]
for (initialisation; condition; increment) {
	// ...
}

\end{lstlisting}}
\defverbatim[colored]\forsyntaxtwo{
\begin{lstlisting}[language=C,tabsize=2]
for (initialisation; condition; increment)
	statment;
\end{lstlisting}}

\defverbatim[colored]\forWrittenUsingWhile{
\begin{lstlisting}[language=C,tabsize=2]
initialisation;
while (condition) {
	// ...
	increment;
}
\end{lstlisting}}

	\begin{frame}{Les boucles}	
		\begin{block}{Syntaxe : boucle pour}
			\forsyntax
			L'instruction \alert{d'initialisation } n'est exécutée qu'au début de la boucle. La \alert{condition} est vérifiée à chaque itération, \alert{l'instruction d'incrémentation} est également exécutée à chaque itération.
		\end{block}
		\begin{alertblock}{Une boucle for peut être écrite comme une boucle while}
			\forWrittenUsingWhile
		\end{alertblock}
	\end{frame}

\defverbatim[colored]\forExmpOne{
\begin{lstlisting}[language=C,tabsize=2]
for (int i = 0; i < 10; i++)
	for (int j = 0; j < 20; j++)
		puts("Hello World");
\end{lstlisting}}

\defverbatim[colored]\forExmpTwo{
\begin{lstlisting}[language=C,tabsize=2]
for (;;)
	puts("Hello World");
\end{lstlisting}}

	\begin{frame}{Les boucles}
		\begin{block}{Syntaxe : boucle pour}
			Comme la syntaxe du \texttt{if}, la boucle pour peut être écrite de cette manière:
			\forsyntaxtwo
		\end{block}
		\begin{center}
			\begin{minipage}[t]{0.48\linewidth}
				\text{Example 1:}
				\forExmpOne
			\end{minipage}
			\begin{minipage}[t]{0.48\linewidth}
				\text{Example 2:}
				\forExmpTwo
			\end{minipage}
		\end{center}
	\end{frame}
	

\defverbatim[colored]\forExmpThree{
\begin{lstlisting}[language=C,tabsize=2]
for (int i = -1; i < 10; i++) {
	break;
	printf("Hello World\n");
}
\end{lstlisting}}

\defverbatim[colored]\forExmpFour{
\begin{lstlisting}[language=C,tabsize=2]
for (int i = -1; i < 10; i++) {
	if (i > 3) continue;
	printf("Hello World\n");
}
\end{lstlisting}}

\defverbatim[colored]\forExmpFive{
\begin{lstlisting}[language=C,tabsize=2]
for (int i = -1; i < 10; i++) {
	continue;
	printf("Hello World\n");
}
\end{lstlisting}}
	
	\begin{frame}{Les boucles}
		\begin{center}
			\begin{minipage}[t]{0.8\linewidth}
				Exemple 1: (\alert{Affiche 200 "Hello World"})
				\forExmpOne
			\end{minipage}
			\begin{minipage}[t]{0.8\linewidth}
				Exemple 2: (\alert{Affiche une infinité de "Hello World"})
				\forExmpTwo
			\end{minipage}
			\begin{minipage}[t]{0.8\linewidth}
				Exemple 3:
				\forExmpThree
			\end{minipage}
		\end{center}
	\end{frame}
	
	\begin{frame}{Les boucles}	
		\begin{minipage}[t]{0.8\linewidth}
			Exemple 3: (\alert{N'affiche rien})
			\forExmpThree
		\end{minipage}
		\begin{minipage}[t]{0.8\linewidth}
			Exemple 4:
			\forExmpFour
		\end{minipage}
		\begin{minipage}[t]{0.8\linewidth}
			Exemple 5:
			\forExmpFive
		\end{minipage}
	\end{frame}

	\begin{frame}{Les boucles}
		\begin{minipage}[t]{0.8\linewidth}
			Exemple 4 :  (\alert{Affiche 5 "Hello World"})
			\forExmpFour
		\end{minipage}
		\begin{minipage}[t]{0.8\linewidth}
			Exemple 5: (\alert{N'affiche rien})
			\forExmpFive
		\end{minipage}
	\end{frame}

\defverbatim[colored]\WhileSyntax{
\begin{lstlisting}[language=C,tabsize=2]
while (condition) {
	// ..
};
\end{lstlisting}}

\defverbatim[colored]\WhileInfinite{
\begin{lstlisting}[language=C,tabsize=2]
while (1) {
	// ..
};
\end{lstlisting}}

	\begin{frame}{Les boucles}
		\begin{block}{Syntaxe : boucle tantque}
			\WhileSyntax
			La boucle continue de s'exécuter jusqu'à ce que la condition soit \alert{fausse}.
		\end{block}
		\begin{exampleblock}{Example d'une boucle infinie :}
			\WhileInfinite
		\end{exampleblock}
	\end{frame}

\defverbatim[colored]\doWhileSyntax{
\begin{lstlisting}[language=C,tabsize=2]
do {
	// ..
} while(condition);
\end{lstlisting}}
	\begin{frame}{Les boucles}
		\begin{block}{Syntaxe : boucle faire ... tantque}
			\doWhileSyntax
			La boucle continue de s'exécuter jusqu'à ce que la condition soit \alert{fausse}. 
			Cette condition est similaire à une boucle tantque, malgrée le fait qu'elle est garantie de s'exécuter au moins une fois.
		\end{block}
	\end{frame}
	
\defverbatim[colored]\structSyntax{
\begin{lstlisting}[language=C,tabsize=2]
struct StructName 
{
	TypeA field1_name;
	TypeB field2_name;
	TypeC field3_name;
	// ...
};
\end{lstlisting}}

\defverbatim[colored]\structExmp{
\begin{lstlisting}[language=C,tabsize=2]
struct A 
{
	int a; // sizeof(int) = 4
	short b; // sizeof(short) = 2
	double b; // sizeof(double) = 8
	char str[256]; // sizeof(char) * 256 = 1 * 256 elements
};	
\end{lstlisting}}

  	\subsection{Les structs}
  	\begin{frame}{Les structs}
  		\begin{block}{Définition et Syntaxe :}
  			Struct, une abréviation de structure, est un type défini par l'utilisateur qui est composé d'autres types qui peuvent ou non être fondamentaux.
  			\structSyntax
  		\end{block}
  	\end{frame}
  
  	\begin{frame}{Les structs}
  		\begin{alertblock}{Quelques remarques :}
  			- La taille d'une structure est la somme de la taille de ses champs. \\
  			- La taille est accessible en utilisant \alert{\texttt{sizeof(struct StructName)}}.
  		\end{alertblock}
  		\begin{exampleblock}{Exeemple:}
  			\structExmp
  			La taille est: \texttt{sizeof(struct A)} = $4 + 2 + 8 + 256 = 270$ octets.
  		\end{exampleblock}
  	\end{frame}
  
\defverbatim[colored]\unionSyntax{
\begin{lstlisting}[language=C,tabsize=2]
union UnionName 
{
	TypeA field1_name;
	TypeB field2_name;
	TypeC field3_name;
	// ...
};
\end{lstlisting}}

\defverbatim[colored]\unionExmp{
\begin{lstlisting}[language=C,tabsize=2]
union A 
{
	int a; // sizeof(int) = 4
	short b; // sizeof(short) = 2
	double b; // sizeof(double) = 8
	char str[256]; // sizeof(char) * 256 = 1 * 256 elements
};	
\end{lstlisting}}

\defverbatim[colored]\unionExmpDanger{
\begin{lstlisting}[language=C,tabsize=2]
union B 
{
	int a;
	short b;
	char str[4];
};
union B var;
var.str[0] = 'T';
var.str[1] = 'N';
var.str[2] = 'C';	
var.str[3] = 'Y';
var.b = 256; // ATTENTION: var.str ne vaut plus TNCY !!!
\end{lstlisting}}
 
 
  	\subsection{Les unions}
  	\begin{frame}{Les unions}
  		\begin{block}{Définition et Syntaxe :}
  			L'union est un type défini par l'utilisateur qui est composé d'autres types qui peuvent ou non être fondamentaux. La mémoire réelle allouée à une union est égale au maximum de ses champs. Tous les champs d'un union partagent donc la même mémoire sous-jacente.
  			\unionSyntax
  		\end{block}

  	\end{frame}
  	
  	\begin{frame}{Les unions}
  		\begin{alertblock}{Quelques remarques:}
  			- La taille d'une union est le maximum des tailles de ses champs. \\
  			- La taille est accessible en utilisant \alert{\texttt{sizeof(union UnionName)}}. \\
  		\end{alertblock}
  		\begin{exampleblock}{Exemple:}
  			\unionExmp
  			La taille est: \texttt{sizeof(union A)} = $max(4, 2, 8, 256) = 256$ octets.
  		\end{exampleblock}
  	\end{frame}

	\begin{frame}{Les unions}
		\begin{alertblock}{ATTENTION : Soyez prudent lorsque vous accédez aux champs d'union. Écrire dans n'importe quel champ d'union peut écraser la mémoire déjà écrite par un autre champ.}
		\unionExmpDanger
		\end{alertblock}
	\end{frame}
  	
  	%%%%%% LA MEMOIRE %%%%%%
  	\begin{frame}{La mémoire}
  		\framesubtitle{Disposition de la mémoire d'un programme}
  		\begin{figure}[!h]
  			\centering
  			\begin{tikzpicture}[scale=0.8]
  				\cell{\texttt{OS / Kernel}}  \cellcom{Haute adresse}
  				\separator
  				\cell{\texttt{Pile}} \coordinate (O1) at (currentcell.center);
  				\padding{2}{} \coordinate (O2) at (currentcell.center);
  				\cell{\texttt{Tas}}  \coordinate (O3) at (currentcell.center);
  				\separator
  				\cell{\texttt{BSS}}  
  				\separator\separator
  				\cell{\texttt{Data}} 
  				\separator
  				\cell{\texttt{Text}} \cellcom{Adresses basses}
  				\cell[draw=none]{L'image mémoire d'un processus (Adresse Virtuel)}
  				\draw[-{Latex[length=4mm]}, ultra thick] ([shift={(1.2,-0.2)}]O1) -- ([shift={(1.2,0.3)}]O2);
  				\draw[-{Latex[length=4mm]}, ultra thick] ([shift={(1.2,0.2)}]O3) -- ([shift={(1.2,-0.3)}]O2);
  				
  				\draw[-{Latex[length=4mm]}, ultra thick] ([shift={(-1.2,-0.2)}]O1) -- ([shift={(-1.2,0.3)}]O2);
  				\draw[-{Latex[length=4mm]}, ultra thick] ([shift={(-1.2,0.2)}]O3) -- ([shift={(-1.2,-0.3)}]O2);
  				
  				\draw[-{Latex[length=4mm]}, ultra thick] ([shift={(0,-0.2)}]O1) -- ([shift={(0,0.3)}]O2);
  				\draw[-{Latex[length=4mm]}, ultra thick] ([shift={(0,0.2)}]O3) -- ([shift={(0,-0.3)}]O2);
  			\end{tikzpicture}
  		\end{figure}
  	\end{frame}
  	
  	\begin{frame}{La mémoire}
  		\framesubtitle{Les différents segments mémoire}
  		\begin{itemize}
  			\item \alert{Pile} : La pile est une région de mémoire (structure LIFO) réservée aux variables locales, à l'environnement de fonctions..
  			\item \alert{Tas} : Le tas est le segment réservé à l'allocation mémoire demandée par le programmeur pour des variables dont la taille ne peut être connue qu'au moment de l'exécution.
  			\item \alert{BSS}\footnote[frame]{Block Started by Symbol} : Les données de ce segment sont initialisées par le kernel à 0 avant que le programme commence à s'exécuter. En générale, ce segment contient toutes les variables \alert{globales} et \alert{statiques} qui sont initialisées à zéro ou qui n'ont pas d'initialisation explicite dans le code source. le segment BSS est \alert{Read-Write}. Le segment BSS est également appelé "\alert{segment de données non initialisé}".
  		\end{itemize}
  	\end{frame}
  
  	\begin{frame}{La mémoire}
  		\framesubtitle{Les différents segments}
  		\begin{itemize}
  			\item \alert{Data} : Le segment de données ou le segment de données initialisé. Cette partie de l'espace d'adressage virtuel d'un programme contient les variables globales et statiques qui sont initialisées par le programmeur. Ce segment peut être encore classé en deux zones :
  			\begin{itemize}
  				\item Zone contenant des données initialisées en lecture seule (RoData).
  				\item Zone contenant des données initialisées en lecture-écriture.
  			\end{itemize}
  			\item \alert{Text} : Le segment de texte, également appelé segment de code, est la section de la mémoire qui contient les instructions exécutables d'un programme.
  		\end{itemize}
  	\end{frame}

\defverbatim[colored]\dataDemoOne{
\begin{lstlisting}[language=C,tabsize=2]
// includes ..
char str1[] = "Hello";
const char* str2 = "World";

int main() {
	str1[0] = 'A';
	str2[0] = 'B';
	puts(str1);
	puts(str2);
}
\end{lstlisting}}
\defverbatim[colored]\dataDemoOneSolution{
\begin{lstlisting}[language=C,tabsize=2]
// includes ..
char str1[] = "Hello";
const char* str2 = "World";

int main() {
	str1[0] = 'A';
	str2[0] = 'B'; // Compilation erreur: str2 is declared const
	puts(str1);
	puts(str2);
}
\end{lstlisting}}

\defverbatim[colored]\dataDemoTwo{
\begin{lstlisting}[language=C,tabsize=2]
// includes ..
char str1[] = "Hello";
char* str2 = "World";

int main() {
	str1[0] = 'A';
	str2[0] = 'B';
	puts(str1);
	puts(str2);
}
\end{lstlisting}}
\defverbatim[colored]\dataDemoTwoSolution{
\begin{lstlisting}[language=C,tabsize=2]
// includes ..
char str1[] = "Hello";
char* str2 = "World";
		
int main() {
	str1[0] = 'A';
	str2[0] = 'B'; // Segfault here
	puts(str1);
	puts(str2);
}
\end{lstlisting}}

\defverbatim[colored]\dataDemoThree{
\begin{lstlisting}[language=C,tabsize=2]
// includes ..

int main() {
	char str1[] = "Hello";
	char* str2 = "World";
	str1[0] = 'A';
	str2[0] = 'B';
	puts(str1);
	puts(str2);
}
\end{lstlisting}}
\defverbatim[colored]\dataDemoThreeSolution{
\begin{lstlisting}[language=C,tabsize=2]
// includes ..
		
int main() {
	char str1[] = "Hello";
	char* str2 = "World";
	str1[0] = 'A';
	str2[0] = 'B'; // Segfault here
	puts(str1);
	puts(str2);
}
\end{lstlisting}}


  	\begin{frame}{La mémoire}
  		\framesubtitle{Pouvez-vous prédire la sortie de ce programme?}
  		Example 1:
  		\dataDemoOne
  	\end{frame}
  	\begin{frame}{La mémoire}
  		\framesubtitle{Ca ne compile même pas}
  		Solution 1:
  		\dataDemoOneSolution
  	\end{frame}
  
  	\begin{frame}{La mémoire}
  		\framesubtitle{Pouvez-vous prédire la sortie de ce programme?}
  		Example 2:
  		\dataDemoTwo
  	\end{frame}
  	\begin{frame}{La mémoire}
  		\framesubtitle{Vos prédiction était probablement fausse}
  		Solution 2:
  		\dataDemoTwoSolution
  	\end{frame}
  
  	\begin{frame}{La mémoire}
  		\framesubtitle{Cela devrait fonctionner}
  		Example 3:
  		\dataDemoThree
  	\end{frame}
  	
  	\begin{frame}{La mémoire}
  		\framesubtitle{Nope, raté}
  		Solution 3:
  		\dataDemoThreeSolution
  	\end{frame}
   	
  	\subsection{La mémoire}
  	\begin{frame}{La mémoire}
  		\framesubtitle{Mémoire statique vs Mémoire dynamique}
  		\begin{block}{Mémoire statique}
  			Une mémoire est appelée \alert{statique } lorsque sa taille est déterminée lors de la \alert{compilation}. Ce type de mémoire est généralement alloué sur la \alert{pile} (stack).
  		\end{block}
  		\begin{block}{Mémoire dynamique}
  			Une mémoire est dite \alert{dynamique} lorsque sa taille est déterminée pendant le temps \alert{d'exécution}. Ce type de mémoire est généralement alloué à partir du \alert{tas} (heap) via un appel système (syscall).
  		\end{block}
  	\end{frame} 	
  
  	\begin{frame}{La mémoire}
  		\framesubtitle{Mémoire statique vs Mémoire dynamique}
  		\begin{alertblock}{
  			Chaque mémoire allouée à partir du tas doit être libérée à un moment donné pendant l'exécution du programme. Pour chaque appel \texttt{*alloc}\footnote[frame]{malloc et calloc}, il doit nécessairement y avoir un appel correspondant à \texttt{free}.}
  		\end{alertblock}
  	\end{frame}
  
  	\begin{frame}{La mémoire}
  		\framesubtitle{Mémoire statique vs Mémoire dynamique}
  		Avantages:
		\begin{itemize}
			\item Il n'y a pas de coût d'allocation.
			\item Cache local la plupart du temps car il est situé dans la pile.
		\end{itemize}
		Inconvénients:
		\begin{itemize}
			\item Très local, en raison de la nature de la pile.
			\item Taille limitée.
			\item La taille doit être fixée pendant la compilation\footnote[frame]{C autorise l'allocation de mémoire sur la pile dont la taille est déterminée lors de l'exécution, ceci est interdit en C++.}.
		\end{itemize}
  	\end{frame}
  
  	\begin{frame}{La mémoire}
  		\framesubtitle{Mémoire statique vs Mémoire dynamique}
  		Avantages:
  		\begin{itemize}
  			\item Flexible, la taille peut être déterminée au moment de l'exécution.
  			\item Globale.
  			\item Peut gérer des tailles que la pile ne peut pas gérer.
  		\end{itemize}
  		Inconvénients:
	  	\begin{itemize}
  			\item L'allocation peut être très coûteuse car elle nécessite un passage du mode utilisateur au mode noyau.
			\item Responsabilité de libérer la mémoire à la fin de l'utilisation.
	  	\end{itemize}
  	\end{frame}


\defverbatim[colored]\mallocExample{
\begin{lstlisting}[language=C,tabsize=2]
void* p1 = malloc(256); // 256 bytes are allocated
int* p2 = (int*)malloc(4 * sizeof(int)); // 4 * sizeof(int) bytes are allocated
struct A* p3 = (struct A*)malloc(2 * sizeof(struct A)); // 2 * sizeof(struct A) bytes are allocated
p2[0]; // Access to uninitialized memory !
p3[0].a; // Access to uninitialized memory !
\end{lstlisting}}
  	\begin{frame}{La mémoire}
  		\framesubtitle{malloc, calloc et realloc}
  		\begin{block}{malloc}
  			\alert{Profile} : \texttt{void* malloc(size\_t size);} \\
  			Alloue ce qui lui est passé comme argument en octets mais \alert{n'effectue aucune initialisation}.
  		\end{block}
  		\begin{exampleblock}{Exemple :}
  			\mallocExample
  		\end{exampleblock}
    \end{frame}

\defverbatim[colored]\callocExample{
\begin{lstlisting}[language=C,tabsize=2]
void* p1 = calloc(1, 256); // 512 bytes are allocated
int* p2 = (int*)calloc(4, sizeof(int)); // 4 * sizeof(int) bytes are allocated
struct A* p3 = (struct A*)calloc(2, sizeof(struct A)); // 2 * sizeof(struct A) bytes are allocated
assert(p2[0] == 0); // true
assert(p3[0].a == 0); // true
assert(p3[1].b == 0); // true
assert(p3[1].str[0] == 0); // true
\end{lstlisting}}
	\begin{frame}{La mémoire}
		\framesubtitle{malloc, calloc et realloc}
		\begin{block}{calloc}
			\alert{Signature} : \texttt{void* calloc(size\_t nmemb, size\_t size);} \\
			Alloue $nmemb * size$ octets et les initialise à zéro.
		\end{block}
		\begin{exampleblock}{Exemple :}
			\callocExample
		\end{exampleblock}
	\end{frame}

\defverbatim[colored]\reallocExampleOne{
\begin{lstlisting}[language=C,tabsize=2]
int* p1 = (int*)calloc(4, sizeof(int)); // 4 * sizeof(int) bytes
p[0] = 1; p[1] = 2; p[2] = 3; p[3] = 4;
int* p2 = (int*)realloc(p1, 6 * sizeof(int));
assert(p2[0] == 1); // true
assert(p2[1] == 2); // true
assert(p2[5] == 6); // Access to uninitialized memory !
assert(p1[5] == 6); // U.B !
\end{lstlisting}}

\defverbatim[colored]\reallocExampleTwo{
\begin{lstlisting}[language=C,tabsize=2]		
int* p3 = (int*)realloc(p2, 3 * sizeof(int));
assert(p3[0] == 1); // true
assert(p3[1] == 2); // true
assert(p3[3] == 3); // U.B!
assert(p2[3] == 3); // U.B!

int* p4 = (int*)realloc(p3, 0); // Equivalent to free(p3)
void* p5 = realloc(NULL, 8); // Equivalent to malloc(8)
void* p6 = realloc(NULL, 0); // Equivalent to malloc(0)
\end{lstlisting}}
	\begin{frame}{La mémoire}
		\framesubtitle{malloc, calloc et realloc}
		\begin{block}{realloc}
			\alert{Profile} : \texttt{void* realloc(void* ptr, size\_t size);} \\
			Change la taille du bloc de mémoire pointé par \texttt{ptr} en \texttt{size} octets. 
			\begin{itemize}
				\item Si \texttt{size} > taille de \texttt{ptr} : La mémoire pointée par le pointeur retourné par \texttt{realloc} sera de taille \texttt{size}. Le contenu de \texttt{ptr} est garanti d'être copié mais la mémoire ajoutée ne sera \alert{pas initialisée}
				\item Si \texttt{size} < taille de \texttt{ptr} : Le contenu de \texttt{ptr} sera copié jusqu'à \texttt{size} octets, le reste du contenu de ptr sera ignoré. La taille de la mémoire pointée par la valeur de retour sera donc \texttt{size}.
				\item Si \texttt{ptr} est \texttt{NULL} : Cela aura le même effet que malloc.
			\end{itemize}
		\end{block}
	\end{frame}

	\begin{frame}{La mémoire}
		\framesubtitle{malloc, calloc et realloc}
		\begin{block}{realloc}
			\begin{itemize}
				\item Si \texttt{size} est $0$ et \texttt{ptr} n'est pas \texttt{NULL} :  Cela aura le même effet que free.
			\end{itemize}
		\end{block}
		\begin{alertblock}{N.B. :}
			- Sauf si \texttt{ptr} est \texttt{NULL}, il doit avoir été renvoyé par un appel antérieur
			à \texttt{malloc()}, \texttt{calloc()} ou \texttt{realloc()}. \\
			- L'accès et/ou l'écriture au pointeur a passé à \texttt{realloc} après l'appel est un \alert{comportement indéfini}\\
		\end{alertblock}
	\end{frame}

	\begin{frame}{La mémoire}
		\framesubtitle{malloc, calloc et realloc}
		\begin{exampleblock}{Exemple :}
			\reallocExampleOne
		\end{exampleblock}
	\end{frame}

	\begin{frame}{La mémoire}
		\framesubtitle{malloc, calloc et realloc}
		\begin{exampleblock}{Exemple :}
			\reallocExampleTwo
		\end{exampleblock}
	\end{frame}

	\begin{frame}{La mémoire}
		\framesubtitle{malloc, calloc et realloc}
		\begin{alertblock}{N.B. :}
			Le standard C ne dit rien quand 0 est passé à \texttt{malloc} (le comportement est spécifique au système d'exploitation).
			\begin{itemize}
				\item Sous Linux : \texttt{malloc(0)} renvoie \texttt{NULL}
				\item Sous Windows : \texttt{malloc(0)} renvoie un pointeur \alert{valide} sur lequel free pourrait être appelé.
			\end{itemize}
		\end{alertblock}
	\end{frame}

	\begin{frame}{La mémoire}
		\framesubtitle{Les pointeurs}
		\begin{block}{Définition}
			Un pointeur est une variable qui contient l'adresse d'une région de mémoire. Un pointeur peut contenir une adresse valide ou non (Exemple : le pointeur \texttt{NULL}). \\
		\end{block}
		Les pointeurs font généralement 4 ou 8 octets en fonction de l'architecture du processeur (32 ou 64 bits): 
		\begin{itemize}
			\item Avec un pointeur 32 bits, nous avons 4 Go de mémoire adressable.
			\item Avec un pointeur 64 bits, nous avons environ 17 milliards de Go de mémoire.
		\end{itemize}
	\end{frame}

\defverbatim[colored]\ptrSyntax{
\begin{lstlisting}[language=C,tabsize=4]	
TypeName* ptr_name; // Recommended
TypeName *ptr_name; // Recommended
TypeName*ptr_name;
TypeName * ptr_name;
\end{lstlisting}}

\defverbatim[colored]\ptrAdrSyntax{
\begin{lstlisting}[language=C,tabsize=4]	
TypeName var = ...;
TypeName* ptr = &var;
\end{lstlisting}}
	\begin{frame}{La mémoire}
		\framesubtitle{Les pointeurs}
		\begin{block}{Syntaxes possibles}
			Toutes les syntaxes suivantes sont valides. Cependant, les deux premiers sont les plus courants :
			\ptrSyntax
		\end{block}
	\end{frame}
	
	\begin{frame}{La mémoire}
		\framesubtitle{Les pointeurs}
		\begin{block}{Comment obtenir l'adresse d'une variable}
			Pour obtenir l'adresse d'une variable, l'opérateur \alert{\&} doit être utilisé. \\
			Exemple :
			\ptrAdrSyntax
		\end{block}
	\end{frame}

	\begin{frame}{La mémoire}
		\framesubtitle{Pointeur et variable sur la pile}
		\begin{figure}[!h]
			\centering
			\begin{tikzpicture}[scale=0.9]
				\stacktop{}
				\separator
				\cell{\texttt{var=42}}  \cellcomL{0xABCDEF00} \coordinate (p1) at (currentcell.east);
				\separator
				\padding{2}{...}
				\separator
				\cell{\texttt{ptr=0xABCDEF00}}  \cellcomL{0xABCDEFBA} \coordinate (p2) at (currentcell.east);
				\separator
				\stackbottom{}
				\cell[draw=none]{La Pile}
				
				\draw[-{Latex[length=3.3mm]}, thick] (p2) .. controls (4,-4) and (4,0) .. (p1);
			\end{tikzpicture}
		\end{figure}
	\end{frame}

	\begin{frame}{La mémoire}
		\framesubtitle{Pointeur sur la pile et variable sur le tas}
		\begin{figure}[!h]
			\centering
			\begin{tikzpicture}[scale=0.8]
				\stacktop{}
				\separator
				\cell{\texttt{ptr=0xABCDEF00}}  \cellcomL{0xFFFFEFBA} \coordinate (p1) at (currentcell.east);
				\separator
				\stackbottom{}
				\cell[draw=none]{La Pile}
				
				\drawstruct{(5,1)})
				\structcell{...}
				\structcell{var=42} \coordinate (p2) at (currentcell.west);
				\structcell{...}
				\draw (5,-3) node{Tas};
				\draw (8,-1) node{0xFFFFEF08};
				
				\draw[-{Latex[length=3.3mm]}, thick] (p1) -- (p2);
			\end{tikzpicture}
		\end{figure}
	\end{frame}
	
\defverbatim[colored]\ptrDerefSyntax{
\begin{lstlisting}[language=C,tabsize=4]	
TypeName var = ...;
TypeName* ptr = &var;
assert(*ptr == var); // true
*ptr = ...; // changed the value of var
\end{lstlisting}}

	\begin{frame}{La mémoire}
		\framesubtitle{Les pointeurs}
		\begin{block}{Comment déréférencer un pointeur}
			Déréférencer un pointeur permet d'accéder à la valeur pointée par le pointeur. Pour cela, l'opérateur \texttt{*} doit être utilisé. \\
			Example:
			\ptrDerefSyntax
		\end{block}
	\end{frame}

\defverbatim[colored]\ptrStructSyntaxOne{
\begin{lstlisting}[language=C,tabsize=4]	
struct StructName* ptr = &var;
ptr->field1_name = ...;
ptr->field2_name[0] = ...; // supposing that field2_name is an array this will change the first element of field2_name
ptr->field1_name; // accessing field1_name in the struct var
ptr->field2_name[0]; // acessing the first element in field2_name in the struct var
\end{lstlisting}}
\defverbatim[colored]\ptrStructSyntaxTwo{
\begin{lstlisting}[language=C,tabsize=4]	
struct StructName* ptr = &var;
(*ptr).field1_name = ...; // *ptr is between parentheses because "*" have a lower percedance level than "."
(*ptr).field2_name[0] = ...; // supposing that field2_name is an array this will change the first element of field2_name
(*ptr).field1_name; // accessing field1_name in the struct var
(*ptr).field2_name[0]; // acessing the first element in field2_name in the struct var
\end{lstlisting}}
	\begin{frame}{La mémoire}
		\framesubtitle{Les pointeurs}
		\begin{alertblock}{ATTENTION :}
			- Déréférencer un pointeur NULL est un comportement indéfini. \\
			- Déréférencer un pointeur sur lequel \texttt{free()} a été appelé est un comportement indéfini.
		\end{alertblock}
	\end{frame}

	\begin{frame}{La mémoire}
		\framesubtitle{Les pointeurs}
		\begin{block}{Accès aux membres d'un struct/union}
			Il existe deux façons d'accéder à un champ struct via un pointeur :\\ 
			\ptrStructSyntaxOne
		\end{block}
	\end{frame}

	\begin{frame}{La mémoire}
		\begin{block}{Accès aux membres d'un struct/union}
			La deuxième façon est verbeuse et donc déconseillée :\\
			\ptrStructSyntaxTwo
		\end{block}
	\end{frame}
	
\defverbatim[colored]\ptrArithExmp{
\begin{lstlisting}[language=C,tabsize=4]		
int* ptr = ...;
ptr1 = ptr + 2; // will add '8' bytes to the current address. 
				// *ptr1 is equivalent to ptr[2]
ptr1++; // will add '4' bytes to ptr1. 
		// *ptr1 is equivalent to ptr[3]
ptr2 = ptr1 - 3; // will substract '12' bytes from ptr1. 
				 // *ptr2 equivalent to ptr1[-3] or ptr[0]
\end{lstlisting}}
	\begin{frame}{La mémoire}
		\framesubtitle{Arithmétique des pointeurs}
		\begin{block}{Explication}
			Un pointeur n'est qu'une adresse mémoire. Cette adresse est une valeur numérique. Par conséquent, on peut effectuer des opérations arithmétiques sur un pointeur comme on peut le faire sur des valeurs numériques.\\ 
			Il existe quatre opérateurs arithmétiques qui peuvent être utilisés sur les pointeurs: \alert{++}, \alert{--}, \alert{+} et \alert{-}.
		\end{block}
		\begin{block}{La formule}
			Pour un pointeur \texttt{ptr} avec le type \texttt{TYPE}, l'expression \texttt{ptr+step} ajoutera \texttt{step*sizeof(TYPE)} octets au pointeur \texttt{ptr}.
		\end{block}
	\end{frame}
  	
  	\begin{frame}{La mémoire}
  		\framesubtitle{Arithmétique des pointeurs}
  		\begin{exampleblock}{Exemple}
  			\ptrArithExmp
  		\end{exampleblock}
  	
  		\begin{alertblock}{Lorsque vous utilisez l'arithmétique du pointeur, veillez à ne pas dépasser la taille allouée.}
  		\end{alertblock}
  	\end{frame}
  	
  	
  	\subsection{Les enums}
  	\subsection{Le keyword static}
  	
  	\include{outils}
  \end{darkframes}
\end{document}
